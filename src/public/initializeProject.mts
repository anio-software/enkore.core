import type {API} from "#~src/API.d.mts"
import type {
	EnkoreLockFile,
	EnkoreTargetIntegrationAPI
} from "@enkore/spec"

import {_debugPrint} from "#~src/internal/_debugPrint.mts"
import {
	getProjectRootFromArgumentAndValidate,
	readEnkoreConfigFile
} from "@enkore/common"
import {initializeCore} from "#~src/internal/initializeCore.mts"
import {loadTargetIntegration} from "#~src/internal/loadTargetIntegration.mts"
import {readLockFile} from "#~src/internal/readLockFile.mts"
import {installToolchain} from "#~src/internal/installToolchain.mts"
import {_readLockFileOrCreateIt} from "#~src/internal/_readLockFileOrCreateIt.mts"
import {_updateLockfileAutogeneratedFiles} from "#~src/internal/_updateLockfileAutogeneratedFiles.mts"

function makeReturnObject(
	projectRoot: string,
	initialLockFile: EnkoreLockFile|null,
	targetIntegrationAPI: EnkoreTargetIntegrationAPI
): Awaited<ReturnType<API["initializeProject"]>> {
	if (initialLockFile === null) {
		throw new Error(`initialLockFile is null, should never get here!`)
	}

	return {
		initialLockFile,
		targetIntegrationAPI,

		async updateLockfileAutogeneratedFiles(files) {
			return await _updateLockfileAutogeneratedFiles(projectRoot, files)
		}
	}
}

const impl : API["initializeProject"] = async function(
	root,
	isCIEnvironment,
	options?
) {
	let initialLockFile: EnkoreLockFile|null = null
	const debug = (msg: string) => _debugPrint(`initializeProject: ${msg}.`)

	const force = options?.force === true
	const npmBinaryPath = options?.npmBinaryPath || "npm"

	debug(`force parameter is ` + (force ? `set` : `not set`))
	debug(`isCIEnvironment parameter is ` + (isCIEnvironment ? `set` : `not set`))

	const projectRoot = await getProjectRootFromArgumentAndValidate(root)
	const projectConfig = await readEnkoreConfigFile(projectRoot)

	const targetIntegrationAPI = await loadTargetIntegration(projectRoot, projectConfig)
	const {
		toolchainID,
		toolchainRev
	} = await targetIntegrationAPI.getToolchainPackageDescriptor()

	const coreData = await initializeCore(projectRoot, projectConfig, toolchainID)

	//
	// in non ci environment, create enkore-lock.json if it didn't exist already
	//
	if (!isCIEnvironment) {
		_debugPrint(`making sure enkore-lock.json exists`)

		initialLockFile = await _readLockFileOrCreateIt(
			projectRoot,
			projectConfig.target.name,
			toolchainID,
			toolchainRev
		)
	}

	const toolchainToInstall = `${toolchainID}@${toolchainRev}`
	const installedToolchain = `${coreData.toolchainID}@${coreData.toolchainRev}`

	debug(`toolchain to install = '${toolchainToInstall}'`)
	debug(`installed toolchain = '${installedToolchain}'`)

	//
	// check early exit condition:
	//
	// - NOT in a CI environment
	// - force NOT set
	// - toolchain specifiers match up
	//
	if (!isCIEnvironment && !force && toolchainToInstall === installedToolchain) {
		debug(`versions match up, doing early return`)

		return makeReturnObject(projectRoot, initialLockFile, targetIntegrationAPI)
	}

	//
	// check early error condition:
	//
	// - in CI environment
	// - lockfile toolchain versions do not match up
	//
	if (isCIEnvironment) {
		//
		// in a CI environment we want to make sure
		// that the target dependencies stamp matches the one
		// saved in the enkore lockfile
		// if not, we throw an error and abort initializing the project
		//
		try {
			const lockfileData = await readLockFile(projectRoot)
			const lockfileToolchainSpecifier = `${lockfileData.toolchainID}@${lockfileData.toolchainRev}`

			if (lockfileToolchainSpecifier !== toolchainToInstall) {
				throw new Error(
					`Toolchain inside enkore-lock.json does not match toolchain to be installed.\n\n` +
					`Expected toolchain          : ${toolchainToInstall}\n` +
					`Toolchain saved in lockfile : ${lockfileToolchainSpecifier}\n`
				)
			}

			initialLockFile = lockfileData
		} catch (error) {
			let errorReason = error instanceof Error ? error.message : "unknown"

			throw new Error(
				`There was an issue processing the enkore-lock.json lockfile.\n` +
				`In a CI environment, this is considered a fatal error.\n\n` +
				`Error: ${errorReason}\n\n` +
				`Please make sure to update and commit the enkore-lock.json lockfile.`
			)
		}
	}

	debug(`installing target dependencies`)

	await installToolchain(
		projectRoot,
		projectConfig,
		coreData,
		dependencyInstallSpecMapToArray(targetDependenciesToInstall),
		targetDependenciesToInstallStamp,
		npmBinaryPath
	)

	return makeReturnObject(projectRoot, initialLockFile, targetIntegrationAPI)
}

export const initializeProject = impl
