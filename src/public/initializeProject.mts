import type {API} from "#~src/API.d.mts"
import type {
	EnkoreLockFile,
	ValidToolchainCombinations,
	EnkoreTargetIntegrationAPI
} from "@enkore/spec"
import {
	getProjectRootFromArgumentAndValidate,
	readEnkoreConfigFile
} from "@enkore/common"
import {log} from "@enkore/debug"
import {loadTargetIntegration} from "#~src/internal/loadTargetIntegration.mts"
import {formatToolchainSpecifier} from "#~src/internal/formatToolchainSpecifier.mts"
import {initialize} from "#~src/internal/initialize.mts"
import {_readLockFileOrCreateIt} from "#~src/internal/_readLockFileOrCreateIt.mts"
import {getCurrentPlatformString} from "#~src/internal/getCurrentPlatformString.mts"
import {readLockFile} from "#~src/internal/readLockFile.mts"
import {_updateLockfileAutogeneratedFiles} from "#~src/internal/_updateLockfileAutogeneratedFiles.mts"
import {installToolchain} from "#~src/internal/installToolchain.mts"

function makeReturnObject(
	projectRoot: string,
	initialLockFile: EnkoreLockFile|null,
	targetIntegrationAPI: EnkoreTargetIntegrationAPI
): Awaited<ReturnType<API["initializeProject"]>> {
	if (initialLockFile === null) {
		throw new Error(`initialLockFile is null, should never get here!`)
	}

	return {
		initialLockFile,
		targetIntegrationAPI,

		async updateLockfileAutogeneratedFiles(files) {
			return await _updateLockfileAutogeneratedFiles(projectRoot, files)
		}
	}
}

const impl: API["initializeProject"] = async function(
	root,
	isCIEnvironment,
	options?
) {
	let initialLockFile: EnkoreLockFile|null = null
	const force = options?.force === true
	const npmBinaryPath = options?.npmBinaryPath ?? "npm"

	const projectRoot = await getProjectRootFromArgumentAndValidate(root)
	const projectConfig = await readEnkoreConfigFile(projectRoot)

	const targetIntegrationAPI = await loadTargetIntegration(projectRoot, projectConfig)

	const toolchainToInstall: ValidToolchainCombinations = await (async () => {
		if (options?.forceToolchain) {
			return options?.forceToolchain
		} else if (projectConfig.target._toolchain) {
			return projectConfig.target._toolchain
		}

		return await targetIntegrationAPI.getToolchainToInstall()
	})()

	log(`force parameter is ` + (force ? `set` : `not set`))
	log(`isCIEnvironment parameter is ` + (isCIEnvironment ? `set` : `not set`))
	log(`npmBinaryPath is '${npmBinaryPath}'`)

	log(
		`toolchainToInstall is '${formatToolchainSpecifier(toolchainToInstall)}'`
	)

	const coreData = await initialize(projectRoot)

	//
	// in non ci environment, create enkore-lock.json if it didn't exist already
	//
	if (!isCIEnvironment) {
		log(`making sure enkore-lock.json exists`)

		initialLockFile = await _readLockFileOrCreateIt(
			projectRoot,
			toolchainToInstall
		)
	}

	if (checkEarlyExit()) {
		log(`check early exit was successfull`)

		return makeReturnObject(
			projectRoot,
			initialLockFile,
			targetIntegrationAPI
		)
	}

	//
	// check early error condition:
	//
	// - in CI environment
	// - lockfile toolchain versions do not match up
	//
	if (isCIEnvironment) {
		//
		// in a CI environment we want to make sure
		// that the toolchain specifier matches the one
		// saved in the enkore lockfile
		// if not, we throw an error and abort initializing the project
		//
		try {
			const lockfileData = await readLockFile(projectRoot)
			const lockfileToolchainSpecifier = formatToolchainSpecifier(lockfileData.toolchain)
			const toolchainToInstallSpecifier = formatToolchainSpecifier(toolchainToInstall)

			if (lockfileToolchainSpecifier !== toolchainToInstallSpecifier) {
				throw new Error(
					`Toolchain inside enkore-lock.json does not match toolchain to be installed.\n\n` +
					`Expected toolchain          : ${toolchainToInstallSpecifier}\n` +
					`Toolchain saved in lockfile : ${lockfileToolchainSpecifier}\n`
				)
			}

			initialLockFile = lockfileData
		} catch (error) {
			let errorReason = error instanceof Error ? error.message : "unknown"

			throw new Error(
				`There was an issue processing the enkore-lock.json lockfile.\n` +
				`In a CI environment, this is considered a fatal error.\n\n` +
				`Error: ${errorReason}\n\n` +
				`Please make sure to update and commit the enkore-lock.json lockfile.`
			)
		}
	}

	await installToolchain(
		projectRoot,
		coreData,
		toolchainToInstall,
		npmBinaryPath
	)

	return makeReturnObject(
		projectRoot,
		initialLockFile,
		targetIntegrationAPI
	)

	//
	// check early exit condition:
	//
	// - NOT in a CI environment
	// - force NOT set
	// - toolchain is installed and matches the requested one
	//
	function checkEarlyExit() {
		const print = (str: string) => {
			log(`checkEarlyExit: ${str}`)
		}

		if (isCIEnvironment) {
			print(`isCIEnvironment is true`)
			return false
		} else if (force) {
			print(`force is true`)
			return false
		} else if (coreData.currentToolchain === false) {
			print(`no toolchain installed`)
			return false
		}

		const {currentToolchain} = coreData

		if (currentToolchain.installedOnPlatform !== getCurrentPlatformString()) {
			print(`platform does not match`)
			return false
		}

		if (currentToolchain.installedID !== toolchainToInstall[0]) {
			print(`toolchain id does not match`)
			return false
		}

		if (currentToolchain.installedRev !== toolchainToInstall[1]) {
			print(`toolchain rev does not match`)
			return false
		}

		return true
	}
}

export const initializeProject = impl
