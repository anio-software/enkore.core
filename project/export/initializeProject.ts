import type {API} from "#~src/API.ts"
import type {
	EnkoreLockFile,
	EnkoreTargetIntegrationAPI
} from "@anio-software/enkore-private.spec"
import type {
	NodePackageJSON,
	ToolchainSpecifier
} from "@anio-software/enkore-private.spec/primitives"
import {
	getProjectRootFromArgumentAndValidate,
	readEnkoreConfigFile
} from "@anio-software/enkore-private.spec/utils"
import {log} from "@anio-software/enkore-private.debug"
import {loadTargetIntegration} from "#~src/internal/loadTargetIntegration.ts"
import {formatToolchainSpecifier} from "#~src/internal/formatToolchainSpecifier.ts"
import {initialize} from "#~src/internal/initialize.ts"
import {_readLockFileOrCreateIt} from "#~src/internal/_readLockFileOrCreateIt.ts"
import {getCurrentPlatformString} from "#~src/internal/getCurrentPlatformString.ts"
import {readLockFile} from "#~src/internal/readLockFile.ts"
import {_updateLockfileAutogeneratedFiles} from "#~src/internal/_updateLockfileAutogeneratedFiles.ts"
import {installToolchain} from "#~src/internal/installToolchain.ts"
import path from "node:path"
import {readFileJSON} from "@anio-software/pkg.node-fs"

function makeReturnObject(
	projectRoot: string,
	initialLockFile: EnkoreLockFile|null,
	namespace: "asint" | "enkore",
	targetIntegrationAPI: EnkoreTargetIntegrationAPI
): Awaited<ReturnType<API["initializeProject"]>> {
	if (initialLockFile === null) {
		throw new Error(`initialLockFile is null, should never get here!`)
	}

	return {
		_targetIntegrationPackageNamespace: namespace,
		initialLockFile,
		targetIntegrationAPI,

		async updateLockfileAutogeneratedFiles(files) {
			return await _updateLockfileAutogeneratedFiles(projectRoot, files)
		}
	}
}

const impl: API["initializeProject"] = async function(
	root,
	isCIEnvironment,
	options?
) {
	let initialLockFile: EnkoreLockFile|null = null
	const force = options?.force === true
	const npmBinaryPath = options?.npmBinaryPath ?? "npm"

	const projectRoot = await getProjectRootFromArgumentAndValidate(root)
	const projectConfig = await readEnkoreConfigFile(projectRoot)
	const projectPackageJSON = (await readFileJSON(
		path.join(projectRoot, "package.json")
	)) as NodePackageJSON

	const {
		targetIntegrationAPI,
		namespace
	} = await loadTargetIntegration(projectRoot, projectConfig)

	const toolchainToInstall: ToolchainSpecifier = await (async () => {
		if (options?.forceToolchain) {
			return options?.forceToolchain
		} else if (projectConfig.target._toolchain) {
			return projectConfig.target._toolchain
		}

		return await targetIntegrationAPI.getToolchainToInstall(
			{
				project: {
					root: projectRoot,
					config: projectConfig,
					packageJSON: projectPackageJSON
				}
			}
		)
	})()

	log(`force parameter is ` + (force ? `set` : `not set`))
	log(`isCIEnvironment parameter is ` + (isCIEnvironment ? `set` : `not set`))
	log(`npmBinaryPath is '${npmBinaryPath}'`)

	log(
		`toolchainToInstall is '${formatToolchainSpecifier(toolchainToInstall)}'`
	)

	const coreData = await initialize(projectRoot)

	//
	// in non ci environment, create enkore-lock.json if it didn't exist already
	//
	if (!isCIEnvironment) {
		log(`making sure enkore-lock.json exists`)

		initialLockFile = await _readLockFileOrCreateIt(
			projectRoot,
			toolchainToInstall
		)
	}

	if (checkEarlyExit()) {
		log(`check early exit was successfull`)

		return makeReturnObject(
			projectRoot,
			initialLockFile,
			namespace,
			targetIntegrationAPI
		)
	}

	//
	// check early error condition:
	//
	// - in CI environment
	// - lockfile toolchain versions do not match up
	//
	if (isCIEnvironment) {
		//
		// in a CI environment we want to make sure
		// that the toolchain specifier matches the one
		// saved in the enkore lockfile
		// if not, we throw an error and abort initializing the project
		//
		try {
			const lockfileData = await readLockFile(projectRoot)
			const lockfileToolchainSpecifier = formatToolchainSpecifier(lockfileData.toolchain)
			const toolchainToInstallSpecifier = formatToolchainSpecifier(toolchainToInstall)

			if (lockfileToolchainSpecifier !== toolchainToInstallSpecifier) {
				throw new Error(
					`Toolchain inside enkore-lock.json does not match toolchain to be installed.\n\n` +
					`Expected toolchain          : ${toolchainToInstallSpecifier}\n` +
					`Toolchain saved in lockfile : ${lockfileToolchainSpecifier}\n`
				)
			}

			initialLockFile = lockfileData
		} catch (error) {
			let errorReason = error instanceof Error ? error.message : "unknown"

			throw new Error(
				`There was an issue processing the enkore-lock.json lockfile.\n` +
				`In a CI environment, this is considered a fatal error.\n\n` +
				`Error: ${errorReason}\n\n` +
				`Please make sure to update and commit the enkore-lock.json lockfile.`
			)
		}
	}

	await installToolchain(
		projectRoot,
		coreData,
		toolchainToInstall,
		npmBinaryPath
	)

	return makeReturnObject(
		projectRoot,
		initialLockFile,
		namespace,
		targetIntegrationAPI
	)

	//
	// check early exit condition:
	//
	// - NOT in a CI environment
	// - force NOT set
	// - toolchain is installed and matches the requested one
	//
	function checkEarlyExit() {
		const print = (str: string) => {
			log(`checkEarlyExit: ${str}`)
		}

		if (isCIEnvironment) {
			print(`isCIEnvironment is true`)
			return false
		} else if (force) {
			print(`force is true`)
			return false
		} else if (coreData.currentToolchain === false) {
			print(`no toolchain installed`)
			return false
		}

		const {currentToolchain} = coreData

		// under certain circumstances the lock file data and core data can get out of sync
		// NB: we never get here in CI mode
		if (initialLockFile !== null) {
			print(`checking if core data and lock file data are out of sync`)

			if (currentToolchain.installedID !== initialLockFile.toolchain[0]) {
				const a = currentToolchain.installedID
				const b = initialLockFile.toolchain[0]

				print(`core data and lock file data is out of sync (${a} != ${b})`)

				return false
			} else if (currentToolchain.installedRev !== initialLockFile.toolchain[1]) {
				const a = currentToolchain.installedRev
				const b = initialLockFile.toolchain[1]

				print(`core data and lock file data is out of sync (${a} != ${b})`)

				return false
			}
		}

		if (currentToolchain.installedOnPlatform !== getCurrentPlatformString()) {
			print(`platform does not match`)
			return false
		}

		if (currentToolchain.installedID !== toolchainToInstall[0]) {
			print(`toolchain id does not match`)
			return false
		}

		if (currentToolchain.installedRev !== toolchainToInstall[1]) {
			print(`toolchain rev does not match`)
			return false
		}

		return true
	}
}

export const initializeProject = impl
